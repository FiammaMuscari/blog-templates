---
title: 'Hablemos de SOLID'
date: '2023-12-18'
tags: ['solid', 'legacy']
images: ['/static/blogs-banner/principios.webp']
draft: false
summary: Te voy a contar por qu茅 es importante conocer los principios SOLID y c贸mo aplicarlos refactorizando tu c贸digo legacy con algunos ejemplos, adelante!
---

# 驴Qu茅 es SOLID?

Los principios S.O.L.I.D. son un conjunto de cinco principios de dise帽o de software que se centran en crear c贸digo m谩s f谩cil de entender, mantener y extender. Estos principios fueron introducidos por Robert C. Martin (pero le vamos a decir T铆o Bob) a principios del 2000 y se han convertido en una parte fundamental de la programaci贸n orientada a objetos.

<img
  src="https://ia802607.us.archive.org/view_archive.php?archive=/31/items/l_covers_0010/l_covers_0010_72.zip&file=0010721801-L.jpg"
  alt="Robert C. Martin photo"
  className="flex m-auto py-[3em]"
/>

# Relaci贸n con Legacy Code

El c贸digo legacy se refiere a <u>c贸digo existente</u> en un proyecto que ha sido creado por otros desarrolladores en el pasado y que puede ser dificil de comprender, mantener y actualizar. Este c贸digo suele usar tecnolog铆as antiguas, pr谩cticas de codificaci贸n no 贸ptimas o tiende a no estar documentado (siempre comenten qu茅 hace su c贸digo capicci? ). Es ac谩 donde aparecen los principios SOLID para salvarnos las papas facilitando la comprensi贸n del c贸digo, reduciendo el acoplamiento y permitiendo extensiones m谩s sencillas.

# Principio de Responsabilidad nica

Un objeto debe tener solo una raz贸n para cambiar, podr铆amos decir que cada clase tiene que "hacer lo suyo" y no meterse en la tarea de otra. (Single Responsibility Principle)

### - Ejemplo en PHP

```js
class Report {
    public $title;
    public $content;

    public function __construct($title, $content) {
        $this->title = $title;
        $this->content = $content;
    }

    public function generateReport() {
        return "Report: {$this->title}\n{$this->content}";
    }

    public function sendEmail($to) {
        $report = $this->generateReport();
        mail($to, 'Report', $report);
    }
}

```

En el primer caso la clase Report tiene dos responsabilidades: generar informes y enviar correos electr贸nicos. Si en el futuro necesitamos cambiar la forma en que se env铆an los correos electr贸nicos, tendremos que modificar la clase Report, lo que viola el principio de responsabilidad 煤nica por lo que har铆amos lo siguiente:

```js
class Report {
    public $title;
    public $content;

    public function __construct($title, $content) {
        $this->title = $title;
        $this->content = $content;
    }

    public function generateReport() {
        return "Report: {$this->title}\n{$this->content}";
    }
}

class EmailSender {
    public function sendEmail($to, $content) {
        mail($to, 'Report', $content);
    }
}


```

# Principio de Abierto/Cerrado

Una clase debe estar abierta para la extensi贸n pero cerrada para la modificaci贸n. Es como tener una caja de herramientas donde podes agregar nuevas herramientas sin necesidad de cambiar las que ya tenes. (Open/Closed Principle)

### - Ejemplo en Go

```go
package main

import "fmt"

type PaymentMethod interface {
    ProcessPayment(amount float64)
}

type CreditCardPayment struct{}

func (c CreditCardPayment) ProcessPayment(amount float64) {
    fmt.Printf("Procesando el pago con tarjeta de cr茅dito: %.2f\n", amount)
}

type PayPalPayment struct{}

func (p PayPalPayment) ProcessPayment(amount float64) {
    fmt.Printf("Procesando el pago con PayPal: %.2f\n", amount)
}

func MakePayment(paymentMethod PaymentMethod, amount float64) {
    paymentMethod.ProcessPayment(amount)
}


```

En el primer caso, si necesitamos agregar un nuevo m茅todo de pago, tendr铆amos que modificar la funci贸n MakePayment, para solucionarlo, podemos crear una interfaz PaymentMethod que implementen las clases de los m茅todos de pago y pasarla como par谩metro a la funci贸n MakePayment:

```go
package main

import "fmt"

type PaymentMethod interface {
    ProcessPayment(amount float64)
}

type CreditCardPayment struct{}

func (c CreditCardPayment) ProcessPayment(amount float64) {
    fmt.Printf("Procesando el pago con tarjeta de cr茅dito: %.2f\n", amount)
}

type PayPalPayment struct{}

func (p PayPalPayment) ProcessPayment(amount float64) {
    fmt.Printf("Procesando el pago con PayPal: %.2f\n", amount)
}

type BankTransferPayment struct{}

func (b BankTransferPayment) ProcessPayment(amount float64) {
    // L贸gica para la transferencia bancaria
    fmt.Printf("Procesando el pago con transferencia bancaria: %.2f\n", amount)
}

func MakePayment(paymentMethod PaymentMethod, amount float64) {
    paymentMethod.ProcessPayment(amount)
}

```

# Principio de Sustituci贸n de Liskov

Cada clase derivada deber铆a ser capaz de ser utilizada como su clase base sin que ello cause fallas o comportamientos inesperados. En otras palabras, al heredar de una clase principal, deber铆amos poder utilizar objetos de las clases derivadas en cualquier contexto donde se espera un objeto de la clase principal. Este principio facilita la extensibilidad y el mantenimiento del c贸digo al permitir la adici贸n de nuevas funcionalidades sin afectar el comportamiento existente. (Liskov Substitution Principle)

### - Ejemplo con Java

```java
class Employee {
    protected String name;

    public Employee(String name) {
        this.name = name;
    }

    public void performDuties() {
        System.out.println("Realizando deberes generales");
    }
}

class Developer extends Employee {
    public Developer(String name) {
        super(name);
    }

    @Override
    public void performDuties() {
        System.out.println("Desarrollando software");
    }

    public void writeCode() {
        System.out.println("Escribiendo c贸digo");
    }
}

class Manager extends Employee {
    public Manager(String name) {
        super(name);
    }

    @Override
    public void performDuties() {
        System.out.println("Gestionando proyectos y equipos");
    }

    public void conductMeetings() {
        System.out.println("Realizando reuniones con el equipo");
    }
}


```

En el primer c贸digo la clase Developer, a pesar de derivar de la clase Employee, introduce un nuevo m茅todo writeCode que no estaba presente en la clase base. Entonces si intentamos utilizar una lista de empleados gen茅ricos en el c贸digo de la empresa (Company) podr铆amos encontrar inconsistencias.

Para corregir esto, movemos el m茅todo performDuties a la clase base Employee, permitiendo que cada clase derivada lo sobrescriba seg煤n sus responsabilidades. Esto nos brinda coherencia al llamar uniformemente a este m茅todo en una lista gen茅rica de empleados, independientemente de su tipo espec铆fico.

```java

public class Company {
    public static void main(String[] args) {
        List<Employee> employees = new ArrayList<>();
        employees.add(new Developer("John"));
        employees.add(new Manager("Jane"));

        // Realizar deberes generales para todos los empleados
        for (Employee employee : employees) {
            employee.performDuties();
        }
    }
}


```

# Principio de Segregaci贸n de Interfaces

No debe obligarse a las clases a implementar interfaces que no usan. En otras palabras, las interfaces deben ser lo m谩s peque帽as y espec铆ficas posible. (Interface Segregation Principle)

### - Ejemplo en C#

```csharp
interface IEmployee
{
    void CalculateSalary();
    void GeneratePerformanceReport();
    void SendEmailNotification();
}

class RegularEmployee : IEmployee
{
    private double baseSalary;

    public RegularEmployee(double baseSalary)
    {
        this.baseSalary = baseSalary;
    }

    public void CalculateSalary()
    {
        double calculatedSalary = baseSalary;

        Console.WriteLine($"El salario calculado es: ${calculatedSalary}");
    }

    public void GeneratePerformanceReport()
    {
        // implementaci贸n vac铆a
    }

    public void SendEmailNotification()
    {
        // implementaci贸n vac铆a
    }
}
```

En el primer caso, la clase RegularEmployee implementa la interfaz IEmployee, pero no necesita implementar los m茅todos GeneratePerformanceReport y SendEmailNotification. Para solucionarlo, podemos dividir la interfaz IEmployee en dos interfaces m谩s peque帽as: ISalaryCalculator e INotification:

```csharp
interface ISalaryCalculator
{
    void CalculateSalary();
}

interface INotification
{
    void SendEmailNotification();
}

class RegularEmployeeSegregated : ISalaryCalculator
{
    private double baseSalary;

    public RegularEmployeeSegregated(double baseSalary)
    {
        this.baseSalary = baseSalary;
    }

    public void CalculateSalary()
    {
        double calculatedSalary = baseSalary;
        Console.WriteLine($"El salario calculado es: ${calculatedSalary}");
    }
}

```

Al dividir la interfaz IEmployee en interfaces m谩s peque帽as y espec铆ficas como ISalaryCalculator e INotification, evitas que las clases que no necesitan ciertos m茅todos se vean obligadas a implementarlos.

# Principio de Inversi贸n de Dependencia

Las clases de alto nivel no deben depender de las clases de bajo nivel. Ambas deben depender de abstracciones. Adem谩s, las abstracciones no deben depender de los detalles, sino los detalles deben depender de las abstracciones. (Dependency Inversion Principle)

### - Ejemplo en Python

```python
class PDFGenerator:
    def generate_pdf(self, data):
        print("Generating PDF report")

class CSVGenerator:
    def generate_csv(self, data):
        print("Generating CSV report")

class ReportGenerator:
    def __init__(self, format_type):
        if format_type == "PDF":
            self.generator = PDFGenerator()
        elif format_type == "CSV":
            self.generator = CSVGenerator()

    def generate_report(self, data):
        self.generator.generate(data)


report_generator = ReportGenerator("PDF")
report_generator.generate_report(data)

```

En el primer caso, la clase ReportGenerator depende de las clases PDFGenerator y CSVGenerator, para solucionarlo, podemos crear una interfaz ReportFormat que implementen las clases PDFGenerator y CSVGenerator, y pasarla como par谩metro al constructor de la clase ReportGenerator:

```python
from abc import ABC, abstractmethod

class ReportGenerator:
    def __init__(self, generator):
        self.generator = generator

    def generate_report(self, data):
        self.generator.generate(data)

class ReportFormat(ABC):
    @abstractmethod
    def generate(self, data):
        pass

class PDFGenerator(ReportFormat):
    def generate(self, data):
        print("Generating PDF report")

class CSVGenerator(ReportFormat):
    def generate(self, data):
        print("Generating CSV report")


pdf_generator = PDFGenerator()
report_generator = ReportGenerator(pdf_generator)
report_generator.generate_report(data)

```

# Conclusi贸n 

Los principios SOLID son como la Biblia del buen c贸digo, f谩cil de mantener y extender. Si bien es posible que no siempre sea posible aplicarlos es importante tenerlos en cuenta al escribir c贸digo para evitar problemas en el futuro. Espero que les haya gustado, cualquier duda o sugerencia me lo pueden dejar ac谩 abajo en los comentarios, buen d铆a y felices fiestas! 
